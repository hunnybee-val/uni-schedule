/// <reference types="node" />
import { PackageJson, PartialDeep, TsConfigJson } from 'type-fest';
import { JsonRoot } from './loadJsonFile';
declare type MaybePromise<T> = T | Promise<T>;
export declare type Options = Partial<{
    /** @default utf-8 */
    encoding: BufferEncoding;
    /**
     * If `false`, FS or JSON errors will be ignored
     * @default true
     *  */
    throws: boolean;
    /**
     * @default "throw" (silent if throws: false)
     * @deprecated use `ifPropertyIsMissing`
     */
    ifFieldIsMissing: 'throw' | 'skip' | 'add';
    /**
     * @default "throw" (silent if throws: false)
     */
    ifPropertyIsMissing: 'throw' | 'skip' | 'add';
    /**
     * - throw - throws (silent if throws: false)
     * - skip - won't call the function
     * - pass - pass the `undefined` value
     * @default "throw"
     * @deprecated use `ifPropertyIsMissingForSetter`
     * */
    ifFieldIsMissingForSetter: 'throw' | 'skip' | 'pass';
    /**
     * - throw - throws (silent if throws: false)
     * - skip - won't call the function
     * - pass - pass the `undefined` value
     * @default "throw"
     * */
    ifPropertyIsMissingForSetter: 'throw' | 'skip' | 'pass';
    /**
     * - null - disable formatting
     * - hard - one hard tab \t
     * - number - number of spaces
     * @default "preserve"
     *  */
    tabSize: null | number | 'preserve' | 'hard';
    /**
     * Allows to modify `jsonc` files (json with comments and trailing commas). These files are usually used by VSCode
     * @default false
     */
    removeJsonc: boolean;
}>;
declare type ModifyProperties<T extends Record<string, any>> = {
    [K in keyof T]?: T[K] | ((oldValue: T[K], json: T) => T[K]);
};
declare type ModifyFunction<T> = (oldJson: T) => MaybePromise<T>;
export declare type ModifyJsonFileFunction<T extends JsonRoot, DefaultName extends boolean = false> = (path: DefaultName extends true ? string | {
    dir: string;
} : string, modifyProperties: T extends Record<string, any> ? ModifyProperties<T> | ModifyFunction<T> : ModifyFunction<T>, options?: Partial<Options>) => Promise<void>;
declare type ModifyJsonFileGenericFunction = <T extends JsonRoot = Record<string, any>>(path: string, modifyProperties: T extends Record<string, any> ? ModifyProperties<T> | ModifyFunction<T> : ModifyFunction<T>, options?: Partial<Options>) => Promise<void>;
/** It's just Error */
/**
 * modifies **original** JSON file
 * You can pass generic, that reflects the structure of original JSON file
 *
 * @param modifyProperties If file contents is object, you can pass properties to merge or callback (can be async). If callback is passed, JSON properties won't be merged. In case if file contents is not an object, you must pass callback.
 */
export declare const modifyJsonFile: ModifyJsonFileGenericFunction;
/**
 * Almost the same is sindresorhus/write-pkg, but with proper typing support and setters for properties
 */
export declare const modifyPackageJsonFile: ModifyJsonFileFunction<PartialDeep<PackageJson>, true>;
export declare const modifyTsConfigJsonFile: ModifyJsonFileFunction<PartialDeep<TsConfigJson>, true>;
export {};
