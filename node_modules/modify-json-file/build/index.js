"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyTsConfigJsonFile = exports.modifyPackageJsonFile = exports.modifyJsonFile = void 0;
const graceful_fs_1 = __importDefault(require("graceful-fs"));
const path_1 = require("path");
const loadJsonFile_1 = require("./loadJsonFile");
/** It's just Error */
// class InnerError extends Error {
//     innerError = true;
// }
/**
 * modifies **original** JSON file
 * You can pass generic, that reflects the structure of original JSON file
 *
 * @param modifyProperties If file contents is object, you can pass properties to merge or callback (can be async). If callback is passed, JSON properties won't be merged. In case if file contents is not an object, you must pass callback.
 */
const modifyJsonFile = async (path, modifyProperties, options = {}) => {
    // TODO handle deprecated gracefully
    if (options.ifFieldIsMissing)
        options.ifPropertyIsMissing = options.ifFieldIsMissing;
    if (options.ifFieldIsMissingForSetter)
        options.ifPropertyIsMissingForSetter = options.ifFieldIsMissingForSetter;
    const { encoding = 'utf-8', throws = true, ifPropertyIsMissing = 'throw', ifPropertyIsMissingForSetter = 'throw', tabSize = 'preserve', removeJsonc = false, } = options;
    try {
        let { json, indent, hasFinalNewline } = await (0, loadJsonFile_1.loadJsonFile)(path, { encoding, tabSize, removeJsonc });
        if (typeof modifyProperties === 'function') {
            // TODO why arg is never
            json = await modifyProperties(json);
        }
        else {
            if (typeof json !== 'object' || Array.isArray(json) || json === null)
                throw new TypeError(`${path}: Root type is not object. Only callback can be used`);
            for (const parts of Object.entries(modifyProperties)) {
                const name = parts[0];
                const value = parts[1];
                const isSetter = typeof value === 'function';
                if (!(name in json)) {
                    const generalAction = isSetter ? ifPropertyIsMissingForSetter : ifPropertyIsMissing;
                    if (generalAction === 'throw')
                        throw new TypeError(`Property to modify "${name}" is missing in ${path}`);
                    if (generalAction === 'skip')
                        continue;
                }
                // `pass` and `add` handled there
                json[name] = isSetter ? value(json[name], json) : value;
            }
        }
        // TODO don't use this fix
        let string = JSON.stringify(json, undefined, indent);
        if (hasFinalNewline)
            string += '\n';
        await graceful_fs_1.default.promises.writeFile(path, string);
    }
    catch (err) {
        if (throws)
            throw err;
    }
};
exports.modifyJsonFile = modifyJsonFile;
// todo: use read-pkg / write-pkg for normalization
/**
 * Almost the same is sindresorhus/write-pkg, but with proper typing support and setters for properties
 */
// TODO remove workaround once my pr is merged
const modifyPackageJsonFile = (path, modify, options = {}) => {
    if (typeof path === 'object') {
        path = (0, path_1.join)(path.dir, 'package.json');
    }
    return (0, exports.modifyJsonFile)(path, modify, { removeJsonc: true, ...options });
};
exports.modifyPackageJsonFile = modifyPackageJsonFile;
const modifyTsConfigJsonFile = (path, modify, options = {}) => {
    if (typeof path === 'object') {
        path = (0, path_1.join)(path.dir, 'tsconfig.json');
    }
    return (0, exports.modifyJsonFile)(path, modify, { removeJsonc: true, ...options });
};
exports.modifyTsConfigJsonFile = modifyTsConfigJsonFile;
